
/* Autogenerated by /usr/bin/instcomp on Wed May 17 03:37:31 2017 -- do not edit */

#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "hal_priv.h"
#include "hal_accessor.h"
#include "hal_internal.h"

static int comp_id;


static char *compname = "pp_stepgen";

#ifdef MODULE_INFO
MODULE_INFO(machinekit, "component:pp_stepgen:Raspberry PI digital output for Machinekit via pigpio library");
MODULE_INFO(machinekit, "pin:#.bcmdir:u32:pincount:in::None");
MODULE_INFO(machinekit, "pin:#.bcmstep:u32:pincount:in::None");
MODULE_INFO(machinekit, "pin:#.velcmd:float:pincount:in::None");
MODULE_INFO(machinekit, "pin:#.poscmd:s32:pincount:out::None");
MODULE_INFO(machinekit, "pin:#.posfb:s32:pincount:out::None");
MODULE_INFO(machinekit, "pin:#.step_period:u32:pincount:out::None");
MODULE_INFO(machinekit, "pin:#.step_count:u32:pincount:out::None");
MODULE_INFO(machinekit, "pin:new_wave:bit:None:io::0");
MODULE_INFO(machinekit, "pin:periodns:u32:None:io::1000000");
MODULE_INFO(machinekit, "pin:pi_instance:u32:None:io::None");
MODULE_INFO(machinekit, "instanceparam:pincount:int::1");
MODULE_INFO(machinekit, "license:GPL");
MODULE_INFO(machinekit, "author:Brian Schousek");
MODULE_INFO(machinekit, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO
RTAPI_TAG(HAL,HC_INSTANTIABLE);


#define MAXCOUNT 5
#define DEFAULTCOUNT 1

static int pincount = 1;
RTAPI_IP_INT(pincount, "");

struct inst_data
    {
    hal_u32_t *_bcmdir[5];
    hal_u32_t *_bcmstep[5];
    hal_float_t *_velcmd[5];
    hal_s32_t *_poscmd[5];
    hal_s32_t *_posfb[5];
    hal_u32_t *_step_period[5];
    hal_u32_t *_step_count[5];
    hal_bit_t *new_wave;
    hal_u32_t *periodns;
    hal_u32_t *pi_instance;
    int local_argc;
    char **local_argv;
    int local_pincount;
    };

static int maxpins __attribute__((unused)) = 5;
static int pp_stepgen_(void *arg, const hal_funct_args_t *fa);

static int instantiate(const int argc, const char**argv);

static int delete(const char *name, void *inst, const int inst_size);

#undef TRUE
#undef FALSE
#undef true
#define true (1)
#undef false
#define false (0)

static int export_halobjs(struct inst_data *ip, int owner_id, const char *name, const int argc, const char **argv)
{
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j __attribute__((unused)) = 0;
    int z __attribute__((unused)) = 0;
    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_u32_newf(HAL_IN, &(ip->_bcmdir[j]), owner_id,
            "%s.%01d.bcmdir", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_u32_newf(HAL_IN, &(ip->_bcmstep[j]), owner_id,
            "%s.%01d.bcmstep", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_float_newf(HAL_IN, &(ip->_velcmd[j]), owner_id,
            "%s.%01d.velcmd", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_s32_newf(HAL_OUT, &(ip->_poscmd[j]), owner_id,
            "%s.%01d.poscmd", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_s32_newf(HAL_OUT, &(ip->_posfb[j]), owner_id,
            "%s.%01d.posfb", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_u32_newf(HAL_OUT, &(ip->_step_period[j]), owner_id,
            "%s.%01d.step-period", name, j);
        if(r != 0) return r;
        }

    z = pincount;
    if(z > maxpins)
       z = maxpins;
    for(j=0; j < z; j++)
        {
        r = hal_pin_u32_newf(HAL_OUT, &(ip->_step_count[j]), owner_id,
            "%s.%01d.step-count", name, j);
        if(r != 0) return r;
        }

    r = hal_pin_bit_newf(HAL_IO, &(ip->new_wave), owner_id,
            "%s.new-wave", name);
    if(r != 0) return r;

    *(ip->new_wave) = 0;
    r = hal_pin_u32_newf(HAL_IO, &(ip->periodns), owner_id,
            "%s.periodns", name);
    if(r != 0) return r;

    *(ip->periodns) = 1000000;
    r = hal_pin_u32_newf(HAL_IO, &(ip->pi_instance), owner_id,
            "%s.pi-instance", name);
    if(r != 0) return r;


// if not set by instantiate() set to default
    if(! ip->local_pincount || ip->local_pincount == -1)
         ip->local_pincount = DEFAULTCOUNT;

    hal_print_msg(RTAPI_MSG_DBG,"export_halobjs() ip->local_pincount set to %d", ip->local_pincount);


    ip->local_argv = halg_dupargv(1, argc, argv);

    ip->local_argc = argc;


    // exporting an extended thread function:
    hal_export_xfunct_args_t __xf = 
        {
        .type = FS_XTHREADFUNC,
        .funct.x = pp_stepgen_,
        .arg = ip,
        .uses_fp = 1,
        .reentrant = 0,
        .owner_id = owner_id
        };

    rtapi_snprintf(buf, sizeof(buf),"%s.funct", name);
    r = hal_export_xfunctf(&__xf, buf, name);
    if(r != 0)
        return r;
    return 0;
}

// constructor - init all HAL pins, funct etc here
static int instantiate(const int argc, const char**argv)
{
struct inst_data *ip;
// argv[0]: component name
const char *name = argv[1];
int r;

// allocate a named instance, and some HAL memory for the instance data
int inst_id = hal_inst_create(name, comp_id, sizeof(struct inst_data), (void **)&ip);

    if (inst_id < 0)
        return -1;

// here ip is guaranteed to point to a blob of HAL memory of size sizeof(struct inst_data).
    hal_print_msg(RTAPI_MSG_DBG,"%s inst=%s argc=%d",__FUNCTION__, name, argc);

// Debug print of params and values
    hal_print_msg(RTAPI_MSG_DBG,"%s: int instance param: %s=%d",__FUNCTION__,"pincount", pincount);
//  if pincount=NN is passed, set local variable here, if not set to default
    int pin_param_value = pincount;
    if((pin_param_value == -1) || (pin_param_value == 0))
        pin_param_value = DEFAULTCOUNT;
    else if((pin_param_value > 0) && (pin_param_value > MAXCOUNT))
        pin_param_value = MAXCOUNT;
    ip->local_pincount = pincount = pin_param_value;
    hal_print_msg(RTAPI_MSG_DBG,"ip->local_pincount set to %d", pin_param_value);

// These pins - pin_ptrs- functs will be owned by the instance, and can be separately exited with delinst
    r = export_halobjs(ip, inst_id, name, argc, argv);
//reset pincount to -1 so that instantiation without it will result in DEFAULTCOUNT
    pincount = -1;

    return r;
}

int rtapi_app_main(void)
{
    comp_id = hal_xinit(TYPE_RT, 0, 0, instantiate, delete, compname);

    if (comp_id < 0)

        return -1;

    hal_ready(comp_id);

    return 0;
}

void rtapi_app_exit(void)
{
    hal_exit(comp_id);
}

// Custom destructor - delete()
// pins, pin_ptrs, and functs are automatically deallocated regardless if a
// destructor is used or not (see below)
//
// Some objects like vtables, rings, threads are not owned by a component
// interaction with such objects may require a custom destructor for
// cleanup actions
// Also allocated memory that hal_lib will know nothing about ie local_argv
//
// NB: if a customer destructor is used, it is called
// - after the instance's functs have been removed from their respective threads
//   (so a thread funct call cannot interact with the destructor any more)
// - any pins and params of this instance are still intact when the destructor is
//   called, and they are automatically destroyed by the HAL library once the
//   destructor returns


static int delete(const char *name, void *inst, const int inst_size)
{

    struct inst_data *ip = inst;

    HALDBG("Entering delete() : inst=%s size=%d %p local_argv = %p\n", name, inst_size, inst, ip->local_argv);

    HALDBG("Before free ip->local_argv[0] = %s\n", ip->local_argv[0]);

   	halg_free_argv(1, ip->local_argv);

    HALDBG("Now ip->local_argv[0] = %s\n", ip->local_argv[0]);

    return 0;

}


#undef FUNCTION
#define FUNCTION(name) static int pp_stepgen_(void *arg, const hal_funct_args_t *fa)
#undef fperiod
#define fperiod (period * 1e-9)
#undef _bcmdir
#define _bcmdir(i) (0+*(ip->_bcmdir[i]))
#undef _bcmstep
#define _bcmstep(i) (0+*(ip->_bcmstep[i]))
#undef _velcmd
#define _velcmd(i) (0+*(ip->_velcmd[i]))
#undef _poscmd
#define _poscmd(i) (*(ip->_poscmd[i]))
#undef _posfb
#define _posfb(i) (*(ip->_posfb[i]))
#undef _step_period
#define _step_period(i) (*(ip->_step_period[i]))
#undef _step_count
#define _step_count(i) (*(ip->_step_count[i]))
#undef new_wave
#define new_wave (*ip->new_wave)
#undef periodns
#define periodns (*ip->periodns)
#undef pi_instance
#define pi_instance (*ip->pi_instance)
#undef local_pincount
#define local_pincount (ip->local_pincount)
#undef local_argc
#define local_argc (ip->local_argc)
#undef local_argv
#define local_argv(i) (ip->local_argv[i])


#line 32 "pp_stepgen.icomp"
#include <pigpiod_if2.h>

//struct gpioPulse_t wavebuild[];//=gpioPulse_t(0,0,0);
gpioPulse_t wavebuild[600];


FUNCTION(_) {
long period __attribute__((unused)) = fa_period(fa);
struct inst_data *ip __attribute__((unused)) = arg;

	int i;
	int n;
	int wave_result;
	//l	int wave[local_pincount];
	int wave;
	//float period;
	unsigned mystep_period;
	unsigned mystep_count;
				
	if (new_wave) {
		rtapi_print_msg(RTAPI_MSG_DBG, "hw rev %x pp version %x pp if version %x", get_hardware_revision(pi_instance), get_pigpio_version(pi_instance), pigpiod_if_version());
		//wave_add_new(pi_instance);
		//wave_add_new(pi_instance);
		wave_clear(pi_instance);
		for (i=0 ; i<local_pincount ; i++) {
			//velocity is steps/s
			//Invert to get period in seconds
			//calculate a period in microseconds
			// then figure out how many of those periods (converted to ns) will fit in periodns (already in ns)


			if (_velcmd(i) != 0) {
				period=(1/_velcmd(i));
				mstep_period=period*1e6;
				mystep_count=periodns/(period/1e9);
				rtapi_print_msg(RTAPI_MSG_DBG, "wave add count %i period %i",mystep_count, mystep_period);
				rtapi_print_msg(RTAPI_MSG_DBG, "wave add gpio %x bitmask %x mode %i",_bcmstep(i),1<<_bcmstep(i), get_mode(pi_instance, _bcmstep(i)));
				
				_step_period(i)=mystep_period;
				_step_count(i)=mystep_count;
				rtapi_print_msg(RTAPI_MSG_DBG, "wave add count %i period %i",mystep_count, mystep_period);
				for (n=0; n<mystep_count; n++) {
					rtapi_print_msg(RTAPI_MSG_DBG, "wave add n %i count %i period %i",n,mystep_count, mystep_period);
					wavebuild[2*n]=(gpioPulse_t){1<<_bcmstep(i), 0,15};
					wavebuild[2*n+1]=(gpioPulse_t){0, 1<<_bcmstep(i), mystep_period-15};
					
				}


				
					//wave_result=wave_add_generic(pi_instance, mystep_count*2, wavebuild);
				wave_result=wave_add_generic(pi_instance, mystep_count*2, wavebuild);
					rtapi_print_msg(RTAPI_MSG_DBG, "add generic count %i %i %i",wave_result, n, mystep_count);
					rtapi_print_msg(RTAPI_MSG_DBG, "wave max us %i actual us %i",wave_get_max_micros(pi_instance),wave_get_micros(pi_instance));
					rtapi_print_msg(RTAPI_MSG_DBG, "wave max pulse %i actual pulse %i",wave_get_max_pulses(pi_instance),wave_get_pulses(pi_instance));
					rtapi_print_msg(RTAPI_MSG_DBG, "wave max cbs %i actual cbs %i",wave_get_max_cbs(pi_instance),wave_get_cbs(pi_instance));
			


			} 
			else {
				mystep_period=1;
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "wave max us %i actual us %i",wave_get_max_micros(pi_instance),wave_get_micros(pi_instance));
			rtapi_print_msg(RTAPI_MSG_DBG, "wave max pulse %i actual pulse %i",wave_get_max_pulses(pi_instance),wave_get_pulses(pi_instance));
			wave=wave_create(pi_instance);
			rtapi_print_msg(RTAPI_MSG_DBG, "wave max us %i actual us %i",wave_get_max_micros(pi_instance),wave_get_micros(pi_instance));
			rtapi_print_msg(RTAPI_MSG_DBG, "wave max pulse %i actual pulse %i",wave_get_max_pulses(pi_instance),wave_get_pulses(pi_instance));
			rtapi_print_msg(RTAPI_MSG_DBG, "wave id %i",wave);
			wave_result=wave_send_once(pi_instance, wave);
			//wave_result=wave_send_repeat(pi_instance, wave);
			
			rtapi_print_msg(RTAPI_MSG_DBG, "wave result %i",wave_result);

			
			rtapi_print_msg(RTAPI_MSG_DBG, "wave tx at %i",wave_tx_at(pi_instance));


			
			//pi.wave_add_generic(wave)
		}
		new_wave=0;
	}
	//wid=pi.wave_create()
	//pi.wave_send_once(wid)
	return 0;

}

/*
FUNCTION(one_wave) {
long period __attribute__((unused)) = fa_period(fa);
struct inst_data *ip __attribute__((unused)) = arg;

	float step_interval;
	float step_count;
	
	float velocity;

	/* step interval in nanoseconds 
	step_interval=1e9/1234;
	step_interval=(_velcmd(i))
	/* step count 
	step_count=periodns/step_interval;

	return step_count;
}



*/

